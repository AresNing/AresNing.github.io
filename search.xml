<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Functions</title>
      <link href="/programming-ideas/programmingideas/cleancode/functions/"/>
      <url>/programming-ideas/programmingideas/cleancode/functions/</url>
      
        <content type="html"><![CDATA[<h1>短小</h1><ul><li>函数的第一规则是要短小，每个函数依序把你带到下一个函数</li><li>函数的缩进层不该多于一层或两层</li></ul><span id="more"></span><h1>只做一件事</h1><ul><li>函数应该只做一件事</li></ul><h1>每个函数一个抽象层级</h1><ul><li>要确保函数只做一件事，函数中的语句都要在同一抽象层级上</li><li>自顶向下的阅读顺序，让每个函数后面都跟着位于下一抽象层级的函数</li></ul><h1>switch语句</h1><ul><li>无法完全避开<code>switch</code>语句，但是能够确保每个<code>switch</code>都埋藏在较低的抽象层级，而且永不重复</li><li>对于<code>switch</code>语句，如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍</li></ul><h1>使用描述性的名称</h1><ul><li>函数越短小，功能越集中，就越便于取个好名字</li><li>长而具有描述性的名称，要比短而令人费解的名称好；长而具有描述性的名称，要比描述性的长注释好</li><li>命名方式要保持一致，使用与模块名一脉相承的短语、名词和动词给函数命名</li></ul><h1>函数参数</h1><ul><li>最理想的是零参数函数，其次是单参数函数，再次是双参数函数，尽量避免三参数函数</li><li>参数与函数名处于相同的抽象层级</li></ul><h2 id="单参数的普遍形式">单参数的普遍形式</h2><ul><li>向函数传入单参数的理由<ol><li>问关于该参数的问题，如<code>boolean isFileExists(&quot;MyFile&quot;)</code></li><li>操作该参数，将其转换为其他东西，再输出之，如<code>InputStream fileOpen(&quot;MyFile&quot;)</code></li><li>事件（event），有输入参数而无输出参数，程序将函数看做一个事件，使用该参数修改系统状态，如<code>void passwordAttemptFailedNtimes(int attempts)</code></li></ol></li></ul><h2 id="flag参数">flag参数</h2><ul><li>不要向函数传入布尔值，否则会使函数不止做一件事</li><li>对于试图向函数传入布尔值，应该将函数一分为二，如<code>renderForSuite()</code>和<code>renderForTest()</code></li></ul><h2 id="双参数函数">双参数函数</h2><ul><li>使用双参数函数会付出理解的代价，应该尽量利用一些机制将其转换成单参数函数，如将<code>writeField(outputStream, name)</code>修改为<code>outputStream.writeField(name)</code>，或者分离出类似<code>FieldWriter</code>的新类，在其构造器中采用<code>outputStream</code>并包含一个<code>write</code>方法</li></ul><h2 id="动词与关键字">动词与关键字</h2><ul><li>对于单参数函数，函数和参数应当形成一个非常良好的动词/名词对形式</li><li>函数名称的关键字（keyword）形式，把名称编码成函数名，如<code>assertEqual</code>改成<code>assertExpertedEqualsActual(expected, actual)</code>，可以大大减轻记忆参数顺序的负担</li></ul><h1>分隔指令和询问</h1><ul><li>函数要么做什么事，要么回答什么事，两件事都干会导致混乱</li></ul><h1>异常处理</h1><ul><li>用异常代替错误码，当返回错误码时，就是在要求调用者立刻处理错误</li><li>用异常代替返回错误码，错误处理代码就能在主路径代码中分离出来</li><li>最好把 try 和 catch 代码块的主体部分抽离出来，另外形成函数</li><li>处理错误的函数不该做其他事，如果 try 在某个函数中存在，它就该是这个函数的第一个单词，而且 catch/finally 代码块后面不该有其他内容</li></ul><h1>如何写出这样的函数</h1><ul><li>先实现，再打磨</li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Ideas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meaningful Names</title>
      <link href="/programming-ideas/programmingideas/cleancode/meaningful-names/"/>
      <url>/programming-ideas/programmingideas/cleancode/meaningful-names/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><ul><li>关于取名的几条简单规则</li></ul><span id="more"></span><h1>避免误导</h1><ul><li>最好别在名称中写出容器类型名，如<code>accountList</code>，即使容器就是个<code>List</code></li><li>提防不同之处太小的名称</li></ul><h1>使用可搜索的名称</h1><ul><li>名称长短应与其作用域大小相对，作用域越小，变量名称越短，如单字母名称仅用于短方法中的本地变量</li><li>用大写下划线字符常量表示数字常量更便于搜索</li></ul><h1>类名</h1><ul><li>类名和对象名应该是名词或名词短语，如<code>Customer</code>、<code>WikiPage</code>、<code>Account</code>等，避免使用<code>Manager</code>、<code>Processor</code>、<code>Data</code>、<code>Info</code>等类名</li><li>类名不应当是动词</li></ul><h1>方法名</h1><ul><li>方法名应当是动词或动词短语，如<code>postPayment</code>、<code>deletePage</code>等</li></ul><h1>每个概念对应一个词</h1><ul><li>函数名称应当独一无二，而且要保持一致</li><li>同一类型的对象应该使用相同的名称后缀，如都使用<code>Controller</code>，而不是又有<code>controller</code>，也有<code>manager</code>、<code>driver</code>等</li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Ideas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Naming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/design-pattern/designpattern/strategy-pattern/"/>
      <url>/design-pattern/designpattern/strategy-pattern/</url>
      
        <content type="html"><![CDATA[<h1>概念</h1><ul><li>策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改，属于<strong>行为型模式</strong></li><li>在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以<strong>互相替换</strong></li><li>通过使用策略模式，可以在<strong>运行时根据需要选择不同的算法，而不需要修改客户端代码</strong></li></ul><span id="more"></span><h1>介绍</h1><h2 id="主要解决">主要解决</h2><ul><li>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</li></ul><h2 id="关键代码">关键代码</h2><ul><li>实现同一个接口</li></ul><h2 id="优点">优点</h2><ol><li>算法可以自由切换</li><li>避免使用多重条件判断</li><li>扩展性良好。</li></ol><h2 id="缺点">缺点</h2><ol><li>策略类会增多</li><li>所有策略类都需要对外暴露</li></ol><h2 id="使用场景">使用场景</h2><ol><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为</li><li>一个系统需要动态地在几种算法中选择一种</li><li>如果一个对象有很多的行为，使用策略模式可避免使用多重的条件选择语句</li></ol><h2 id="注意事项">注意事项</h2><ul><li>不推荐经典策略模式，更推荐<strong>简单策略用枚举策略模式</strong>，<strong>复杂策略用工厂策略模式</strong></li></ul><h1>实现</h1><blockquote><p><strong>引入例子</strong></p><ul><li>需求：对一份股票数据列表，给出低价榜、高价榜、涨幅榜；其中只有排序条件的区别，比较适合作为策略模式的例子</li></ul></blockquote><h2 id="经典策略模式">经典策略模式</h2><h3 id="基本思路">基本思路</h3><ul><li>创建表示各种策略的对象、一个行为随着策略对象改变而改变的 context 对象</li><li>策略对象改变 context 对象</li><li>策略模式通过将算法与使用算法的代码解耦，提供了一种动态选择不同算法的方法；客户端代码不需要知道具体的算法细节，而是通过调用上下文类来使用所选择的策略</li></ul><h3 id="核心角色">核心角色</h3><ul><li>上下文（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。上下文类可以通过依赖注入、简单工厂等方式来获取具体策略对象</li><li>抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法</li><li>具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现</li></ul><h3 id="代码实现">代码实现</h3><ol><li>数据DTO</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 股票交易代码</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现价</span></span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涨幅</span></span><br><span class="line">    <span class="keyword">private</span> Double rise;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Getter and Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>抽象策略接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将股票列表排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序后的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>策略实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高价值排行榜</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighPriceRank</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Stock::getPrice).reversed())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 低价排名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowPriceRank</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Stock::getPrice))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高涨幅排名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRiseRank</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Stock::getRise).reversed())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Context类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略模式的上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">getRank</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.sort(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>抽象调用接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RankService</span> &#123;</span><br><span class="line">    List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(String rankType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>调用实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序服务实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RankServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">RankService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Stock&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(String rankType)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建上下文</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="comment">// 选择策略</span></span><br><span class="line">        <span class="keyword">switch</span> (rankType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HighPrice&quot;</span>:</span><br><span class="line">                context.setStrategy(<span class="keyword">new</span> <span class="title class_">HighPriceRank</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;LowPrice&quot;</span>:</span><br><span class="line">                context.setStrategy(<span class="keyword">new</span> <span class="title class_">LowPriceRank</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HighRise&quot;</span>:</span><br><span class="line">                context.setStrategy(<span class="keyword">new</span> <span class="title class_">HighRiseRank</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;rankType not found!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  执行策略</span></span><br><span class="line">        <span class="keyword">return</span> context.getRank(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意">注意</h3><ul><li>经典策略模式，创建了一个接口、三个策略类，还是比较啰嗦的。调用类的实现也待商榷，新增一个策略类还要修改榜单实例</li></ul><h2 id="枚举策略模式">枚举策略模式</h2><h3 id="代码实现-v2">代码实现</h3><ol><li>枚举策略类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RankEnum</span> &#123;</span><br><span class="line">    <span class="comment">// 策略实例</span></span><br><span class="line">    HighPrice &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> source.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Stock::getPrice).reversed())</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    LowPrice &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> source.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Stock::getPrice))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    HighRise &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> source.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Stock::getRise).reversed())</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RankServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">RankService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Stock&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(String rankType)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取策略，若未匹配会抛IllegalArgumentException</span></span><br><span class="line">        <span class="type">RankEnum</span> <span class="variable">rank</span> <span class="operator">=</span> RankEnum.valueOf(rankType);</span><br><span class="line">        <span class="keyword">return</span> rank.sort(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-v2">注意</h3><ul><li>对这种简单的策略，推荐用枚举进行优化。枚举的本质是创建了一些静态类的集合</li><li>正确地使用枚举策略模式需要额外考虑以下几点：<ul><li>枚举的策略类是公用且静态，这意味着这个策略过程不能引入非静态的部分，扩展性受限</li><li>策略模式的目标之一，是优秀的扩展性和可维护性，最好能新增或修改某一策略类时，对其他类是无改动的。而枚举策略如果过多或者过程复杂，维护是比较困难的，可维护性受限</li></ul></li></ul><h2 id="工厂策略模式">工厂策略模式</h2><h3 id="代码实现-v3">代码实现</h3><ol><li>策略实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 高价榜  </span></span><br><span class="line"><span class="comment"> * 注意申明 Service.value = HighPrice,他是我们的key,下同  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Service(&quot;HighPrice&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighPriceRank</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> source.stream()  </span><br><span class="line">                .sorted(Comparator.comparing(Stock::getPrice).reversed())  </span><br><span class="line">                .collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 低价榜  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Service(&quot;LowPrice&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowPriceRank</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> source.stream()  </span><br><span class="line">                .sorted(Comparator.comparing(Stock::getPrice))  </span><br><span class="line">                .collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 高涨幅榜  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Service(&quot;HighRise&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRiseRank</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(List&lt;Stock&gt; source)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> source.stream()  </span><br><span class="line">                .sorted(Comparator.comparing(Stock::getRise).reversed())  </span><br><span class="line">                .collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用实现类（借助spring工厂特性完成注入）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RankServiceImpl3</span> <span class="keyword">implements</span> <span class="title class_">RankService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Stock&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Strategy&gt; rankMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Stock&gt; <span class="title function_">sort</span><span class="params">(String rankType)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取策略，若未匹配会抛IllegalArgumentException</span></span><br><span class="line">        <span class="keyword">if</span> (!rankMap.containsKey(rankType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;rankType not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取策略实例</span></span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> rankMap.get(rankType);</span><br><span class="line">        <span class="comment">// 执行策略</span></span><br><span class="line">        <span class="keyword">return</span> strategy.sort(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-v3">注意</h3><ul><li>为了解决良好的扩展性和可维护性，可以考虑Spring自带的BeanFactory的优势，实现基于工厂的策略模式；也可以自己实现一个抽象工厂</li><li>工厂策略模式会比枚举策略模式啰嗦，但也更加灵活、易扩展性和易维护</li><li>因此，简单策略推荐枚举策略模式，复杂策略才推荐工厂策略模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
            <tag> Strategy Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/java-basics/javabasics/polymorphism/"/>
      <url>/java-basics/javabasics/polymorphism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下文来自 <em>On Java 8 - Chapter 9</em></p></blockquote><h1>前言</h1><ul><li>多态，也称为动态绑定、后期绑定、运行时绑定</li><li>Java 中除了<code>static</code>和<code>final</code>方法（<code>private</code>方法也是隐式的<code>final</code>）外，其他所有方法都是后期绑定<ul><li>指明<code>final</code>可以防止方法被重写，有效地”关闭了“动态绑定</li><li>然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用<code>final</code>，而不是为了提升性能而使用</li></ul></li></ul><span id="more"></span><h1>陷阱：重写私有方法</h1><ul><li>需要小心重写<code>private</code>方法的现象，编译器不报错，但可能不会按预期的执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrivateOverride</span> <span class="variable">po</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output: private f()</span><br><span class="line"><span class="comment"># 你可能期望输出public f()，然而private方法可以当作是final的</span></span><br><span class="line"><span class="comment"># 因为基类版本的f()屏蔽了Derived，因此它都不算是重写方法</span></span><br></pre></td></tr></table></figure><ul><li>为了清晰起见，<ul><li>派生类中的方法名采用与基类中<code>private</code>方法名不同的命令</li><li>使用<code>@Override</code>注解，以便检测问题</li></ul></li></ul><h1>陷阱：属性与静态方法</h1><ul><li><strong>只有普通的方法调用可以是多态的</strong></li></ul><h2 id="属性">属性</h2><ul><li>当子类对象向上转型为父类引用时，任何属性访问都被编译器解析，因此不是多态的，此时访问同名属性，得到的是父类的属性</li><li>当子类引用时，默认的属性不是父类版本的属性，为了获取父类属性，需要显式地指明<code>super.field</code></li><li>为了避免以上令人困惑的问题，<ul><li>通常会将所有属性都指明为<code>private</code>，因此不能直接访问它们，只能通过方法访问</li><li>尽量不要给基类属性和派生类属性起相同的名字</li></ul></li></ul><h2 id="静态方法">静态方法</h2><ul><li>如果一个方法是静态（<code>static</code>）的，其行为不具有多态性</li><li>静态方法只与类相关，与单个的对象无关</li></ul><h1>构造器和多态</h1><h2 id="构造器调用顺序">构造器调用顺序</h2><ol><li>在所有事发生前，分配给对象的存储空间会被初始化为二进制0</li><li>基类构造器被调用。该步骤被递归重复，类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类<ul><li>如果在基类构造器中调用普通方法，会调用子类重写后的方法</li></ul></li><li>按声明顺序初始化成员</li><li>调用派生类构造器的方法体</li></ol><h2 id="编写构造器的一条良好规范">编写构造器的一条良好规范</h2><ul><li>尽量不要调用类中的任何方法</li><li>在基类的构造器中能安全调用的只有基类的<code>final</code>方法（也适用于可被看作是<code>final</code>的<code>private</code>方法），因为这些方法不能被重写，因此不会产生意想不到的结果</li></ul><h2 id="继承和清理">继承和清理</h2><ul><li>由于继承，如果需要特殊的清理工作，必须在派生类中重写<code>dispose()</code>方法，记得调用基类的<code>dispose()</code>方法，否则基类的清理工作不会发生</li><li>销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对象<ul><li>对于属性而言，意味着与声明的顺序相反</li><li>对于基类，首先进行派生类的清理工作，然后是基类的清理（因为派生类的清理可能会调用基类的一些方法，所以基类组件不能过早地被销毁）</li></ul></li><li>一旦某个成员对象被其他一个或多个对象共享时，不能只是简单地调用<code>dispose()</code>，也许必须使用<strong>引用计数</strong>来跟踪仍然访问着共享对象的对象数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shared</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">refcount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// long型防止溢出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> counter++;  <span class="comment">// id是final，id值在初始化确定后不应该变化</span></span><br><span class="line">    </span><br><span class="line">    Shared() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> viud <span class="title function_">addRef</span><span class="params">()</span> &#123;</span><br><span class="line">        refcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(--refcount == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Disposing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>协变返回类型</h1><ul><li>协变返回类型，表示派生类的被重写方法可以返回基类方法返回类型的派生类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grain</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheat</span> <span class="keyword">extends</span> <span class="title class_">Grain</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mill</span> &#123;</span><br><span class="line">    Grain <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Grain</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WheatMill</span> <span class="keyword">extends</span> <span class="title class_">Mill</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Wheat <span class="title function_">process</span><span class="params">()</span> &#123;  <span class="comment">// 协变返回类型，Grain -&gt; Wheat</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wheat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Never Nester</title>
      <link href="/programming-ideas/programmingideas/codeaesthetic/nervernester/"/>
      <url>/programming-ideas/programmingideas/codeaesthetic/nervernester/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p><a href="https://www.bilibili.com/video/BV1ov4y167WE/?spm_id_from=333.788&amp;vd_source=67965098e45142f3b4fb66fb1ceeb39a">代码美学：为何要成为“不嵌套主义者”</a></p><p><a href="https://youtu.be/CFRhGnuXG-4">https://youtu.be/CFRhGnuXG-4</a></p></blockquote><h1>消除嵌套的方法</h1><h2 id="条件反转">条件反转</h2><ul><li>guard语句</li><li>验证守护 validation gatekeeping</li><li>error first 风格</li><li>return early 尽早返回</li></ul><h2 id="提炼子函数">提炼子函数</h2><blockquote><p>评论区：</p><p>0、如何硬着头皮开始？首先要有信念。<br>众所周知，代码在编译时会首先得到AST，这意味着任何复杂函数都可以抽象成最简单的两两关系——我们不会做得这么绝，但是务必要有这样的信心。</p><p>1、如何判断一个函数是否需要抽象？可以把“50行”当作一个指标。<br>20年前一些老派的公司做CodeReview时，会把代码打印到纸上。如果哪个函数长到需要翻页才能看全，Reviewer就会摆出嫌弃的表情，然后把你挂掉。</p><p>2、如何判断提炼的子函数的好坏？有两个硬指标：<br>一是子函数依赖的参数个数，二是子函数的复用次数。<br>子函数复用越多，参数越少，就说明拆解越是有效。</p><p>3、当你提炼出多个子函数，而它们之间使用到的参数有相似之处时，可以将它们进一步抽象成类。<br>类就是绑定在数据上的函数。</p><p>4、可以用Map、Reduce、Filter这些高阶函数配合Lambda表达式来代替简单循环，在处理缺乏抽象的数据结构时有奇效。如果你的语言是C#，请务必尽可能大胆地使用LInQ；Python可以适当运用列表推导式，但要顾及同事的感受。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Programming Ideas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Naming </tag>
            
            <tag> Ode Aesthetic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Naming Patterns</title>
      <link href="/programming-ideas/programmingideas/codeaesthetic/namingpatterns/"/>
      <url>/programming-ideas/programmingideas/codeaesthetic/namingpatterns/</url>
      
        <content type="html"><![CDATA[<blockquote><p>There are only two hard things in computer science: cache invalidation and naming things.– Phil Karlton</p></blockquote><span id="more"></span><blockquote><p><a href="https://www.bilibili.com/video/BV1nP4y1v7ww/?spm_id_from=333.999.0.0&amp;vd_source=67965098e45142f3b4fb66fb1ceeb39a">代码美学：在代码中取名</a></p><p><a href="https://youtu.be/-J3wNP6u5YU">https://youtu.be/-J3wNP6u5YU</a></p></blockquote><ul><li>避免使用单字母</li><li>避免使用缩写</li><li>命名不要携带变量类型信息，推荐带上单位</li><li>如果你不知道基类如何命名，那么你可能需要修改子类的名字</li><li>尝试将工具类的方法放在不同的类中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Ideas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Naming </tag>
            
            <tag> Code Aesthetic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigInteger &amp; BigDecimal</title>
      <link href="/java-basics/javabasics/big-integer-and-big-decimal/"/>
      <url>/java-basics/javabasics/big-integer-and-big-decimal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/noteless/p/9877957.html">基础类型BigInteger简介</a></p><p><a href="https://www.cnblogs.com/noteless/p/9896139.html#22">基础类型BigDecimal简介</a></p></blockquote><h1>BigInteger 和 BigDecimal</h1><ul><li>BigInteger 支持任意长度的整数；BigDecimal 支持任意精度的浮点数，可以用它进行精确的计算</li><li>BigInteger 和 BigDecimal 均是<strong>不可变</strong>的</li></ul><span id="more"></span><ul><li>创建<ul><li><code>new BigXxx()</code></li><li><code>BigXxx.valueOf()</code></li><li><code>Scanner对象.nextBigXxx()</code></li></ul></li><li>方法<ul><li>加减乘除：<code>add()</code>，<code>substract()</code>，<code>multiple()</code>，<code>divide()</code>，<code>remainder()</code>，<code>divideAndRemainder()</code>，<code>max()</code>，<code>min()</code></li><li>比较：<code>compareTo()</code></li><li>转换：<code>BigXxx对象.intValue()</code>，<code>doubleValue()</code></li><li>舍入模式：<code>BigDecimal对象.divide(BigDecimal, RoundingMode)</code>，如<code>RoundingMode.HALF_UP</code>四舍五入</li></ul></li></ul><h1>使用BigDecimal精度丢失问题</h1><ul><li>问题：使用<code>new BigDecimal(double val)</code>，传入参数为<code>double</code>类型发生精度丢失</li><li>原因：<code>double</code>不能表示为任何有限长度的二进制小数</li><li><strong>解决方法</strong>：<ol><li>使用<code>new BigDecimal(String)</code>构造函数，创建一个参数以<strong>字符串表示数值</strong>的对象</li><li>浮点数使用<code>valueOf</code>方法</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.12</span>;</span><br><span class="line">        <span class="comment">// 方法一：BigDecimal构造函数使用String来创建</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.12&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(d));  <span class="comment">// valueOf源码中的对应操作</span></span><br><span class="line">        <span class="comment">// 方式二：浮点数使用valueOf方法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal3</span> <span class="operator">=</span> BigDecimal.valueOf(d);</span><br><span class="line">        </span><br><span class="line">        System.out.println(bigDecimal);</span><br><span class="line">        System.out.println(bigDecimal2);</span><br><span class="line">        System.out.println(bigDecimal3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>比较 BigDecimal</h1><ul><li>比较 BigDecimal 用<code>compareTo</code>方法，例如：<code>if(bigDecimal1.compareTo(bigDecimal2) == 0) &#123;...&#125;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 两个BigDecimal的比较</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// false, 等号比较的是地址，两个对象的地址不同</span></span><br><span class="line">        <span class="keyword">if</span>(bigDecimal1 == bigDecimal2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bigDecimal1 == bigDecimal2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// false, equals方法中有标度比较，两个对象的标度不同</span></span><br><span class="line">        <span class="comment">// if(scale != val.scale()) return false;</span></span><br><span class="line">        <span class="keyword">if</span>(bigDecimal1.equals(bigDecimal2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bigDecimal1.equals(bigDecimal2)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// true, compareTo去掉了标度比较，只比较值的大小</span></span><br><span class="line">        <span class="keyword">if</span>(bigDecimal1.compareTo(bigDecimal2) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bigDecimal1.compareTo(bigDecimal2) == 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BigInteger </tag>
            
            <tag> BigDecimal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/java-basics/javabasics/final/"/>
      <url>/java-basics/javabasics/final/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下文来自 <em>On Java 8 - Chapter 8 Reuse</em></p></blockquote><h1>前言</h1><ul><li><code>final</code>表示”这是不能改变的“</li><li>可能使用<code>final</code>的三个地方：数据、方法、类</li></ul><span id="more"></span><h1><code>final</code>数据</h1><ul><li>对于基本类型，<code>final</code>使数据恒定不变</li><li>对于对象引用，<code>final</code>使引用恒定不变：一旦引用被初始化执行了某个对象，它就不能改为指向其他对象；但是，对象本身是可以修改的</li></ul><h1>空白<code>final</code></h1><ul><li>空白<code>final</code>：没有初始化值的<code>final</code>属性</li><li>编译器确保空白<code>final</code>在使用前必须被初始化，既能使一个类的每个对象的<code>final</code>属性值不同，也能保持它的不变性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Poppet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    Poppet(<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlankFinal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> j;  <span class="comment">// Blank final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Poppet p;  <span class="comment">// Blank final reference</span></span><br><span class="line">    <span class="comment">// Blank finals MUST be initialized in constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlankFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">Poppet</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlankFinal</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        j = x;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">Poppet</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><code>final</code>参数</h1><ul><li>在参数列表中，将参数声明为<code>final</code>意味着在方法中不能改变参数指向的对象或基本变量</li><li><code>final</code>基本类型参数，只能读取而不能修改参数，主要用于传递数据给匿名内部类</li></ul><h1><code>final</code>方法</h1><ul><li>使用<code>final</code>方法的原因<ol><li>给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变</li><li>（现在已经不推荐）效率考虑，</li></ol></li><li>应该让编译器和 JVM 处理性能问题，只有在为了明确禁止覆写方法时才使用<code>final</code></li></ul><h1><code>final</code>类</h1><ul><li><code>final</code>修饰一个类，说明它不能被继承</li><li><code>final</code>类的属性可以根据个人选择是或不是<code>final</code></li><li>由于<code>final</code>禁止继承，类中所有方法都被隐式指定为<code>final</code>，所以无法覆写它们</li><li>原因：是因为类的设计永远不需要改动，或者是处于安全考虑不希望它有子类</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> final </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/java-basics/javabasics/new-in-java-8/"/>
      <url>/java-basics/javabasics/new-in-java-8/</url>
      
        <content type="html"><![CDATA[<h1>Lambda表达式</h1><h2 id="本质">本质</h2><ul><li>Lambda表达式的实质是<strong>函数式接口的实例</strong></li><li>所以以前用匿名内部类表示的，现在都可以用Lambda表达式来写</li></ul><h2 id="语法">语法</h2><ul><li><code>-&gt;</code>：箭头操作符</li><li>左侧：Lambda表达式的形参列表，也就是抽象方法的形参列表</li><li>右侧：Lambda表达式的方法体，也就是重写的抽象方法的方法体</li></ul><h2 id="语法总结">语法总结</h2><ul><li>左侧：<ul><li>Lambda形参列表的参数类型可以省略（类型推断）</li><li>如果Lambda形参列表只有一个参数，则小括号<code>()</code>可省略</li></ul></li><li>右侧：<ul><li>Lambda体应该用大括号<code>&#123;&#125;</code>包裹</li><li>如果Lambda体只有一条执行语句（包括<code>return</code>语句），则大括号<code>&#123;&#125;</code>和<code>return</code>关键字都可以省略</li></ul></li></ul><span id="more"></span><h1>函数式接口</h1><h2 id="定义">定义</h2><ul><li>如果一个接口中，只声明了一个抽象方法，则该接口为函数式接口</li><li>可以在接口上使用<code>@FunctionalInterface</code>注解，以检查它是否是一个函数式接口</li></ul><h2 id="使用举例">使用举例</h2><h3 id="Java内置四大核心函数式接口">Java内置四大核心函数式接口</h3><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td><code>Consumer&lt;T&gt;</code>消费型接口</td><td><code>T</code></td><td><code>void</code></td><td>对类型为<code>T</code>的对象应用操作，包含方法：<code>void accept(T t)</code></td></tr><tr><td><code>Supplier&lt;T&gt;</code>供给型接口</td><td>/</td><td><code>T</code></td><td>返回类型为<code>T</code>的对象，包含方法：<code>T get()</code></td></tr><tr><td><code>Function&lt;T, R&gt;</code>函数型接口</td><td><code>T</code></td><td><code>R</code></td><td>对类型为<code>T</code>的对象应用操作，并返回类型为<code>R</code>的对象，包含方法：<code>R appply(T t)</code></td></tr><tr><td><code>Predicate&lt;T&gt;</code>断定型接口</td><td><code>T</code></td><td><code>boolean</code></td><td>确定类型为<code>T</code>的对象是否满足某约束，并返回<code>boolean</code>值，包含方法：<code>boolean test(T t)</code></td></tr></tbody></table><h3 id="其他接口">其他接口</h3><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>T, U</code></td><td><code>R</code></td><td>对类型为<code>T, U</code>的对象应用操作，返回<code>R</code>类型结果，包含方法：<code>R apply(T t, U u)</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code>（<code>Function</code>子接口)</td><td><code>T</code></td><td><code>T</code></td><td>对类型为<code>T</code>的对象进行一元运算，并返回类型为<code>T</code>的对象，包含方法：<code>T appply(T t)</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code>（<code>BiFunction</code>子接口)</td><td><code>T, T</code></td><td><code>T</code></td><td>对类型为<code>T</code>的对象进行二元运算，并返回类型为<code>T</code>的对象，包含方法：<code>T appply(T t1, T t2)</code></td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>void</code></td><td>对类型为<code>T, U</code>的对象应用操作，包含方法：<code>void accept(T t, U u)</code></td></tr><tr><td><code>BiPredicate&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>boolean</code></td><td>确定类型为<code>T, U</code>的对象是否满足某约束，并返回<code>boolean</code>值，包含方法：<code>boolean test(T t, U u)</code></td></tr><tr><td><code>ToIntFunction&lt;T&gt;</code><br /><code>ToLongFunction&lt;T&gt;</code><br /><code>ToDoubleFunction&lt;T&gt;</code></td><td><code>T</code></td><td><code>int</code><br /><code>long</code><br /><code>double</code></td><td>分别计算<code>int</code>、<code>long</code>、<code>double</code>值的函数</td></tr><tr><td><code>IntFunction&lt;T&gt;</code><br /><code>LongFunction&lt;T&gt;</code><br /><code>DoubleFunction&lt;T&gt;</code></td><td><code>int</code><br /><code>long</code><br /><code>double</code></td><td><code>R</code></td><td>参数分别为<code>int</code>、<code>long</code>、<code>double</code>类型的函数</td></tr></tbody></table><h2 id="总结">总结</h2><table><thead><tr><th>函数式接口名称</th><th>方法名称</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>Runnable</code></td><td><code>run</code></td><td>无参数</td><td>无</td></tr><tr><td><code>Function</code></td><td><code>apply</code></td><td>1个参数</td><td>有</td></tr><tr><td><code>Consumer</code></td><td><code>accept</code></td><td>1个参数</td><td>无</td></tr><tr><td><code>BiConsumer</code></td><td><code>accept</code></td><td>2个参数</td><td>无</td></tr><tr><td><code>Supplier</code></td><td><code>get</code></td><td>无参数</td><td>有</td></tr></tbody></table><h1>方法引用与构造器引用</h1><h2 id="方法引用-Method-References">方法引用 Method References</h2><h3 id="本质-v2">本质</h3><ul><li>方法引用本质上是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字指向一个方法</li><li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li></ul><h3 id="格式">格式</h3><ul><li><code>类/对象::方法名</code></li><li>有三种情况：<ol><li><code>对象::实例方法名</code></li><li><code>类::静态方法名</code></li><li><code>类::实例方法名</code></li></ol></li></ul><h3 id="要求">要求</h3><ul><li>实现函数式接口的抽象方法的参数列表和返回类型，必须与方法引用的方法的参数列表和返回类型一致（针对情况1和2）</li></ul><h2 id="构造器引用">构造器引用</h2><h3 id="本质-v3">本质</h3><ul><li>和方法引用类似</li><li>函数式接口的抽象方法的参数列表和构造器的参数列表一致，抽象方法的返回类型即为构造器所属的类的类型</li></ul><h3 id="格式-v2">格式</h3><ul><li><code>类::new</code>，如<code>String::new</code></li></ul><h2 id="数组引用">数组引用</h2><h3 id="本质-v4">本质</h3><ul><li>可以将数组看做是一个特殊的类，则写法与构造器引用一致</li></ul><h3 id="格式-v3">格式</h3><ul><li><code>数组名::new</code>，如<code>String[]::new</code></li></ul><h1>Stream API</h1><h2 id="本质-v5">本质</h2><ul><li>Stream关注的是对数据的运算，与CPU打交道</li><li>集合关注的是数据的存储，与内存打交道</li></ul><h2 id="特性">特性</h2><ol><li>Stream自己不会存储数据</li><li>Stream不会改变源对象；相反，它们会返回一个持有结果的新Stream</li><li>Stream操作是延迟执行的，这意味着它们会等到需要结果的时候才执行</li></ol><h2 id="执行流程">执行流程</h2><h3 id="1-Stream的实例化，创建Stream">1. Stream的实例化，创建Stream</h3><h4 id="方式一：通过集合">方式一：通过集合</h4><ul><li>Java8中的<code>Collection</code>接口被扩展，可通过两个默认方法获取流<ol><li><code>default Stream&lt;E&gt; stream()</code>：返回一个顺序流</li><li><code>default Stream&lt;E&gt; parallelStream()</code>：返回一个并行流</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; parallelStream = list.parallelStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：通过数组">方式二：通过数组</h4><ul><li>Java8中的<code>Arrays</code>的静态方法<code>stream()</code>可以获取流<ol><li><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code></li></ol></li><li>重载形式，能够处理对应基本类型的数组：<ol><li><code>public static IntStream stream(int[] array)</code></li><li><code>public static LongStream stream(long[] array)</code></li><li><code>public static DoubleStream stream(double[] array)</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">    Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Arrays.stream(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式三：通过Stream的of方法">方式三：通过Stream的of方法</h4><ul><li>可以调用Stream类静态方法<code>of()</code>，通过显示值创建一个流，它可以接收任意数量的参数<ol><li><code>public static &lt;T&gt; Stream&lt;T&gt; of(T... values)</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Stream&lt;<span class="type">int</span>[]&gt; stream1 = Stream.of(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四：创建无限流">方式四：创建无限流</h4><ul><li>可以使用静态方法<code>Stream.iterate()</code>和<code>Stream.generate()</code>创建无限流<ol><li>迭代：<code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li><li>生成：<code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="comment">// 迭代前10个偶数并打印输出</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="comment">// 生成10个随机数并打印输出</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-一系列中间操作（filter，map，…）">2. 一系列中间操作（filter，map，…）</h3><h4 id="筛选与切片">筛选与切片</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filter(Predicate p)</code></td><td>接收Lambda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>筛选，通过流所生成元素的<code>hashCode()</code>和<code>equals()</code>去除重复元素</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><code>skip(long n)</code></td><td>跳过元素，返回一个去掉了前<code>n</code>个元素的流。若流中元素不足<code>n</code>个，则返回一个空流。与<code>limit(n)</code>互补</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    list.stream().filter(x -&gt; x &gt; <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line">    list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="映射">映射</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的<code>DoubleStream</code></td></tr><tr><td><code>mapToInt(ToIntFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的<code>IntStream</code></td></tr><tr><td><code>mapToLong(ToLongFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的<code>LongStream</code></td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StreamAPITest.java</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    list.stream().map(StreamAPITest::fromStringToStream).forEach(s -&gt; s.forEach(System.out::println));</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    list.stream().flatMap(StreamAPITest::fromStringToStream).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">fromStringToStream</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character c : s.toCharArray()) &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>map</code>和<code>flatMap</code>，可以类比成<code>List</code>的<code>add</code>和<code>addAll</code></li></ul><h4 id="排序">排序</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>sorted()</code></td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td><code>sorted(Comparator com)</code></td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">23</span>, <span class="number">231</span>, <span class="number">2</span>, -<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-终止操作">3. 终止操作</h3><h4 id="匹配与查找">匹配与查找</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>allMatch(Predicate p)</code></td><td>检查是否匹配所有元素</td></tr><tr><td><code>anyMatch(Predicate p)</code></td><td>检查是否至少匹配一个元素</td></tr><tr><td><code>noneMatch(Predicate p)</code></td><td>检查是否没有匹配所有元素</td></tr><tr><td><code>findFirst()</code></td><td>返回第一个元素</td></tr><tr><td><code>findAny()</code></td><td>返回当前流中的任意元素</td></tr><tr><td><code>count()</code></td><td>返回流中元素总数</td></tr><tr><td><code>max(Comparator com)</code></td><td>返回流中最大值</td></tr><tr><td><code>min(Comparator com)</code></td><td>返回流中最小值</td></tr><tr><td><code>forEach(Consumer c)</code></td><td><strong>内部迭代</strong>（使用<code>Collection</code>接口需要用户去做迭代，称为<strong>外部迭代</strong>；相反，Stream API使用内部迭代，即其内部实现了迭代）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> list.stream().allMatch(x -&gt; x &gt; <span class="number">1</span>);</span><br><span class="line">    System.out.println(allMatch);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(x -&gt; x &gt; <span class="number">1</span>);</span><br><span class="line">    System.out.println(anyMatch);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> list.stream().noneMatch(x -&gt; x &gt; <span class="number">1</span>);</span><br><span class="line">    System.out.println(noneMatch);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; first = list.stream().findFirst();</span><br><span class="line">    System.out.println(first);  <span class="comment">// Optional[1]</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; any = list.stream().findAny();</span><br><span class="line">    System.out.println(any);  <span class="comment">// Optional[1]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count();</span><br><span class="line">    System.out.println(count);  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; max = list.stream().max(Integer::compare);</span><br><span class="line">    System.out.println(max);  <span class="comment">// Optional[4]</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; min = list.stream().min(Integer::compare);</span><br><span class="line">    System.out.println(min);  <span class="comment">// Optional[1]</span></span><br><span class="line"></span><br><span class="line">    list.stream().forEach(System.out::println);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归约">归约</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>reduce(T iden, BinaryOperator b)</code></td><td>可以将流中元素反复结合起来，得到一个值，返回<code>T</code></td></tr><tr><td><code>reduce(BinaryOperator b)</code></td><td>可以将流中元素反复结合起来，得到一个值，返回<code>Optional&lt;T&gt;</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(reduce);  <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce1</span> <span class="operator">=</span> list.stream().reduce(<span class="number">10</span>, Integer::sum);</span><br><span class="line">    System.out.println(reduce1);  <span class="comment">// 65</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; reduce2 = list.stream().reduce(Integer::sum);</span><br><span class="line">    System.out.println(reduce2);  <span class="comment">// Optional[55]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>map</code>和<code>reduce</code>的连接通常称为<code>map-reduce</code>模式，常用于分布式和大数据应用</li></ul><h4 id="收集">收集</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>collect(Collector c)</code></td><td>将流转换为其他形式。接收一个<code>Collector</code>接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><ul><li><code>Collector</code>接口方法中的实现决定了如何对流执行收集的操作，如收集到<code>List</code>，<code>Set</code>，<code>Map</code>等</li><li><strong><code>Collectors</code>实用类</strong>提供了许多静态方法，可以方便创建常见的收集器实例，具体方法与实例如下表：</li></ul><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td><code>toList</code></td><td><code>List&lt;T&gt;</code></td><td>把流中元素收集到<code>List</code></td></tr><tr><td><code>toSet</code></td><td><code>Set&lt;T&gt;</code></td><td>把流中元素收集到<code>Set</code></td></tr><tr><td><code>toCollection</code></td><td><code>Collection&lt;T&gt;</code></td><td>把流中元素收集到创建的<code>Collection</code></td></tr><tr><td><code>counting</code></td><td><code>Long</code></td><td>计算流中元素的个数</td></tr><tr><td><code>summingInt</code></td><td><code>Integer</code></td><td>对流中元素的整数属性求和</td></tr><tr><td><code>averageingInt</code></td><td><code>Double</code></td><td>计算流中元素<code>Integer</code>属性的平均值</td></tr><tr><td><code>summarizingInt</code></td><td><code>IntSummaryStatistics</code></td><td>收集流中<code>Integer</code>属性的统计值，如：平均值</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/collectors-api-1.png" alt="collectors-api-1"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/collectors-api-2.png" alt="collectors-api-2"></p><h2 id="说明">说明</h2><ol><li>一个中间操作链，对数据源的数据进行操作</li><li>一旦执行终止操作，才执行中间操作，并产生结果，也称为”惰性求值“。之后，该Stream不会再被使用</li></ol><h1>Optional</h1><h2 id="作用">作用</h2><ul><li>解决空指针异常，如果值存在则<code>isPresnet()</code>方法会返回<code>true</code>，调用<code>get()</code>方法会返回该对象</li><li><code>Optional&lt;T&gt;</code>类（<code>java.util.Optional</code>）是一个<strong>容器类</strong>，它可以保存类型<code>T</code>的值，代表这个值存在；或者仅仅保存<code>null</code>，表示这个值不存在</li><li>原本用<code>null</code>表示一个值不存在，现在<code>Optional</code>可以更好地表达这一概念，且可以避免空指针异常</li></ul><h2 id="创建Optional类对象的方法">创建Optional类对象的方法</h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Optional.of(T t)</code></td><td>创建一个<code>Optional</code>实例，<code>t</code>必须非空</td></tr><tr><td><code>Optional.empty()</code></td><td>创建一个空的<code>Optional</code>实例</td></tr><tr><td><strong><code>Optional.ofNullable(T t)</code></strong></td><td><strong>创建一个<code>Optional</code>实例，<code>t</code>可以为<code>null</code></strong></td></tr></tbody></table><h2 id="判断Optional容器中是否包含对象">判断Optional容器中是否包含对象</h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>boolean isPresent()</code></td><td>判断是否包含对象</td></tr><tr><td><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code></td><td>如果有值，就执行<code>Consumer</code>接口的实现代码，并且该值作为参数传给它</td></tr></tbody></table><h2 id="获取Optional容器的对象">获取Optional容器的对象</h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>T get()</code></td><td>如果有值，返回该值，否则抛异常</td></tr><tr><td><strong><code>T orElse(T other)</code></strong></td><td><strong>如果有值则将其返回，否则返回指定的<code>other</code>对象</strong></td></tr><tr><td><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code></td><td>如果有值则将其返回，否则返回由<code>Supplier</code>接口实现提供的对象</td></tr><tr><td><code>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td><td>如果有值则将其返回，否则抛出由<code>Supplier</code>接口实现提供的异常</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java Basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Lambda </tag>
            
            <tag> Functional Interface </tag>
            
            <tag> Stream </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC的三大辅助类</title>
      <link href="/concurrency/concurrency/concurrent-notes/three-auxiliary-classes-of-juc/"/>
      <url>/concurrency/concurrency/concurrent-notes/three-auxiliary-classes-of-juc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CountDownLatch，CyclicBarrier，Semaphore</p></blockquote><span id="more"></span><h1><code>CountDownLatch</code> 减小计数</h1><ul><li><code>CountDownLatch </code>类可以设置一个计数器，然后通过 <code>countDown </code>方法来进行 减 1 的操作，使用 <code>await</code> 方法等待计数器不大于 0，然后继续执行 <code>await </code>方法 之后的语句</li><li><code>CountDownLatch</code> 主要有两个方法<ul><li>当一个或多个线程调用 <code>await </code>方法时，这些线程会阻塞</li><li>其它线程调用 <code>countDown </code>方法会将计数器减 1，调用 <code>countDown </code>方法的线程不会阻塞</li><li>当计数器的值变为 0 时，因 <code>await</code> 方法阻塞的线程会被唤醒，继续执行</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 定义计数器，设置初始值</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; quit&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();  <span class="comment">//计数器减一,不会阻塞</span></span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countDownLatch.await();  <span class="comment">//主线程 await 休息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部离开后自动唤醒主线程</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><code>CyclicBarrier</code> 循环栅栏</h1><ul><li><code>CyclicBarrier</code> 的构造方法第一个参数是目标障碍数<ul><li><code>CyclicBarrier</code> 支持一个可选的 <code>Runnable</code> 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次</li></ul></li><li>每次执行 <code>CyclicBarrier </code>一次障碍数会加 1，如果达到了目标障碍数，才会执行<code>cyclicBarrier.await()</code>之后的语句</li><li>可以将 <code>CyclicBarrier </code>理解为加 1 操作， <code>CountDownLatch </code>理解为减 1 操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建CyclicBarrier，设置目标值[，设置到达目标值之后的动作]</span></span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt; &#123;</span><br><span class="line">        System.out.println(NUMBER + <span class="string">&quot; threads come to the barrier!!!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread come to the barrier...&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();  <span class="comment">// 在barrier处等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><code>Semaphore</code> 信号量</h1><ul><li><p><code>Semaphore </code>的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证</p><ul><li><code>Semaphore </code>的构造方法有一个可选参数是设置是否为公平锁</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>acquire</code> 方 法获得许可证，<code>release </code>方法释放许可</p></li><li><p><code>Semaphore </code>通常用于限制可以访问某些资源（物理或逻辑的）的线程数目</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Semaphore，设置最大信号量</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取许可</span></span><br><span class="line">                semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquires the resource...&quot;</span>);</span><br><span class="line">                <span class="comment">// 随机生成占用资源时间</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; --- releases the resource&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> CountDownLatch </tag>
            
            <tag> CyclicBarrier </tag>
            
            <tag> Semaphore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程开发步骤</title>
      <link href="/concurrency/concurrency/concurrent-notes/steps-of-multithread-development/"/>
      <url>/concurrency/concurrency/concurrent-notes/steps-of-multithread-development/</url>
      
        <content type="html"><![CDATA[<h1>基本步骤</h1><span id="more"></span><ol><li>创建资源类，定义属性和操作方法</li><li>资源类的操作方法<ul><li>上锁</li><li>判断</li><li>业务操作</li><li>通知</li><li>解锁</li></ul></li><li>创建多个线程，调用资源类的操作方法，运行线程</li><li>防止虚假唤醒问题<ul><li>在<code>while</code>内判断是否符合条件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写锁</title>
      <link href="/concurrency/concurrency/concurrent-notes/read-write-lock/"/>
      <url>/concurrency/concurrency/concurrent-notes/read-write-lock/</url>
      
        <content type="html"><![CDATA[<h1>读写锁</h1><ul><li><p>读写互斥，读读共享</p><ul><li>读锁：共享锁</li><li>写锁：独占锁/排它锁</li></ul></li><li><p>无论读锁还是写锁，都会发生死锁（读-写死锁，写-写死锁）</p></li></ul><span id="more"></span><h1><code>ReentrantReadWriteLock</code></h1><ul><li>实现了<code>ReadWriteLock</code>接口</li><li>提供<code>readLock()</code>方法，<code>writeLock()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建读写锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="comment">// 写锁</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is writing &quot;</span> + key);</span><br><span class="line">            <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finish writing &quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放写锁</span></span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 读锁</span></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is getting &quot;</span> + key);</span><br><span class="line">            <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            result = cache.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finish getting &quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放读锁</span></span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>深入</h1><ol><li>无锁<ul><li>缺点：导致并发问题</li></ul></li><li>添加独占锁：<code>synchronized</code>和<code>ReentrantLock</code><ul><li>缺点：读读不能共享，读性能差</li></ul></li><li>读写锁：<code>ReentrantReadWriteLock</code><ul><li>优点：读读共享，提升性能；读写/写写互斥，保证并发安全</li><li>缺点：<ul><li><strong>造成锁饥饿</strong>：一直读，写不了（没有写操作）；写锁是独占的，写的时候不能读；读锁是共享的，如果读并发很多的时候，写锁一直进不去，导致锁饥饿</li><li>写的时候不能读，只能写完之后才能读（但是持有写锁的线程，可以继续获取读锁）</li></ul></li></ul></li></ol><h1>读写锁的降级</h1><ul><li><strong>将写锁降级为读锁</strong><ul><li>获取写锁 ➡️ 获取 ➡️ 读锁释放写锁（此时降级为读锁）➡️  释放读锁（最终为无锁状态）</li></ul></li><li>在线程持有读锁的情况下，该线程不能取得写锁（因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有）</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写 锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）</li><li>原因：<ul><li>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此<strong>不能把 获取读锁的线程“升级”为写锁</strong></li><li>而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个<strong>写锁就“降级”为了读锁</strong></li></ul></li></ul><blockquote><p>❗ <strong>读锁不能升级为写锁</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/concurrency/concurrency/concurrent-notes/thread-local/"/>
      <url>/concurrency/concurrency/concurrent-notes/thread-local/</url>
      
        <content type="html"><![CDATA[<h1>ThreadLocal 简介</h1><h2 id="概念">概念</h2><ul><li>该类提供线程局部变量。 这些变量与它们的正常对应物的不同之处在于，访问其中的每个线程（通过其<code>get</code>或<code>set</code>方法）具有其自己的、独立初始化的变量副本</li><li><code>ThreadLocal</code>实例通常是希望<strong>将状态与线程相关联的类中的私有静态字段（例如，用户ID或事务ID）</strong></li><li>只要线程处于活动状态且<code>ThreadLocal</code>实例可访问，每个线程都拥有对其线程局部变量副本的隐式引用; 在一个线程消失之后，它的所有线程局部实例副本都要进行垃圾收集（除非存在对这些副本的其他引用）</li></ul><span id="more"></span><h2 id="注意事项">注意事项</h2><ul><li><p><code>ThreadLocal</code>的初始化使用<code>withInitial</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; threadLocalField = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>阿里巴巴编程规范：</p><ul><li><p>必须回收自定义的<code>ThreadLocal</code>变量，尤其在线程池场景下，线程经常会被复用，<strong>如果不清理自定义的<code> ThreadLocal</code>变量，可能会影响后续业务逻辑和造成内存泄露</strong>等问题</p></li><li><p>尽量在代理中使用<code>try-finally</code>块进行回收。 正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objectThreadLocal.set(userInfo); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    objectThreadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>源码分析</h1><h2 id="Thread、ThreadLocal、ThreadLocalMap-关系">Thread、ThreadLocal、ThreadLocalMap 关系</h2><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/thread-threadlocal-threadlocalmap.png" alt="thread-threadlocal-threadlocalmap"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/thread-threadlocal-threadlocalmap-2.png" alt="thread-threadlocal-threadlocalmap-2"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/thread-local-map.png" alt="thread-local-map"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/thread-threadlocal-threadlocalmap-3.png" alt="thread-threadlocal-threadlocalmap-3"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/thread-threadlocal-threadlocalmap-4.png" alt="thread-threadlocal-threadlocalmap-4"></p><h1>内存泄露问题</h1><h2 id="为什么要用”弱引用“">为什么要用”弱引用“</h2><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/threadlocal-weak-reference.png" alt="threadlocal-weak-reference"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/threadlocal-weak-reference-2.png" alt="threadlocal-weak-reference-2"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/threadlocal-weak-reference-3.png" alt="threadlocal-weak-reference-3"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/threadlocal-weak-reference-4.png" alt="threadlocal-weak-reference-4"></p><h2 id="最佳实践">最佳实践</h2><ol><li><p><code>ThreadLocal.withInitial(() -&gt; 初始化值);</code>，避免空指针异常</p></li><li><p>建议把<code>ThreadLocal</code>修饰为<code>static</code></p><ul><li><p>阿里巴巴编程规范</p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/threadlocal-static.png" alt="threadlocal-static"></p></li></ul></li><li><p>用完<code>ThreadLocal</code>记得手动<code>remove</code>，清除<code>key</code>为<code>null</code>的脏<code>Entry</code></p></li></ol><h1>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/threadlocal-summary.png" alt="threadlocal-summary"></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合的线程安全</title>
      <link href="/concurrency/concurrency/concurrent-notes/thread-safe-of-collection/"/>
      <url>/concurrency/concurrency/concurrent-notes/thread-safe-of-collection/</url>
      
        <content type="html"><![CDATA[<h1>快速失败</h1><ul><li><code>java.util</code>下的集合都是快速失败的</li><li>集合的遍历是通过迭代器实现的，迭代器迭代时会检查<code>modCount == expectedModCount</code>，如果进行并发修改，可能导致<code>modCount != expectedModCount</code>，导致并发修改异常</li><li>如<code>ArrayList</code></li></ul><span id="more"></span><h1>安全失败</h1><ul><li><code>JUC</code>下的集合是安全失败的</li><li>迭代器遍历的是原集合的副本，所以对集合进行并发操作，不会发生<code>modCount != expectedModCount</code>，但是在遍历时不会读到新修改的值，即牺牲了读正确性</li></ul><h1>解决集合的线程不安全</h1><h2 id="对于ArrayList">对于<code>ArrayList</code></h2><ul><li><code>Vector</code>（不推荐使用，性能低）</li><li><code>Collections</code>包装，得到线程安全集合，如<code>Collections.synchronizedList()</code>（不推荐使用，性能低）</li><li><code>CopyOnWriteArrayList</code>，利用写时复制技术（推荐使用，但会牺牲读正确性）</li></ul><h2 id="对于HashSet">对于<code>HashSet</code></h2><ul><li><code>CopyOnWriteArraySet</code></li></ul><h2 id="对于HashMap">对于<code>HashMap</code></h2><ul><li><code>ConcurrentHashMap</code></li></ul><h1><code>CopyOnWriteArrayList</code></h1><blockquote><p><a href="https://blog.csdn.net/u010002184/article/details/90452918">CopyOnWriteArrayList原理，优缺点，使用场景</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/concurrency/concurrency/concurrent-notes/thread-pool/"/>
      <url>/concurrency/concurrency/concurrent-notes/thread-pool/</url>
      
        <content type="html"><![CDATA[<h1>线程池框架</h1><ul><li>Java 中的线程池是通过<code>Executor</code>框架实现的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/thread-pool-framework.png" alt="thread-pool-framework"></p><span id="more"></span><h1>线程池参数</h1><blockquote><p><strong>创建线程池推荐适用<code>ThreadPoolExecutor</code>及其 7 个参数手动创建</strong></p></blockquote><ul><li><code>corePoolSize</code>：线程池的核心线程数</li><li><code>maximumPoolSize</code>：能容纳的最大线程数</li><li><code>keepAliveTime</code>：空闲线程存活时间</li><li><code>unit</code>：存活的时间单位</li><li><code>workQueue</code>：存放提交但未执行任务的队列</li><li><code>threadFactory</code>：创建线程的工厂类</li><li><code>handler</code>：等待队列满后的拒绝策略</li></ul><blockquote><p>当提交的任务数大于（<code>workQueue.size()</code>+<code>maximumPoolSize</code>），就会触发线程池的拒绝策略</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">3</span>,  <span class="comment">// corePoolSize</span></span><br><span class="line">        <span class="number">5</span>,  <span class="comment">// maximumPoolSize</span></span><br><span class="line">        <span class="number">10</span>,  <span class="comment">// keepAliveTime</span></span><br><span class="line">        TimeUnit.MICROSECONDS,  <span class="comment">// unit</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),  <span class="comment">// workQueue</span></span><br><span class="line">        Executors.defaultThreadFactory(),  <span class="comment">// threadFactory</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());  <span class="comment">// handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;execute...&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>拒绝策略</h1><ul><li><code>CallerRunsPolicy</code>：当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li><li><code>AbortPolicy</code>：丢弃任务，并抛出拒绝执行<code>RejectedExecutionException</code>异常 信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行</li><li><code>DiscardPolicy</code>：直接丢弃，无其他处理</li><li><code>DiscardOldestPolicy</code>：当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列<code>workQueue</code>中最老的一个任务，并将新任务加入</li></ul><h1>线程池底层工作原理</h1><ol><li>在创建了线程池后，线程池中的线程数为零</li><li>当调用<code>execute()</code>方法添加一个请求任务时，线程池会做出如下判断：<ul><li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列</li><li>如果这个时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程立刻运行这个任务</li><li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做超过一定的时间（<code>keepAliveTime</code>）时，线程会判断：</li></ol><ul><li>如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小</li></ul><h1>注意</h1><blockquote><p>阿里巴巴 Java 开发手册</p><p>【强制】线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明：<code>Executors</code>返回的线程池对象的弊端如下：<br>1）<code>FixedThreadPool</code>和<code>SingleThreadPool</code>:<br>允许的请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致<code>OOM</code>。<br>2）<code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>:<br>允许的创建线程数量为<code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致<code>OOM</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> Thread Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信</title>
      <link href="/concurrency/concurrency/concurrent-notes/inter-thread-communication/"/>
      <url>/concurrency/concurrency/concurrent-notes/inter-thread-communication/</url>
      
        <content type="html"><![CDATA[<h1>synchronized</h1><h2 id="wait-notify-notifyAll"><code>wait</code> + <code>notify/notifyAll</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1>Lock</h1><h2 id="wait-notify-notifyAll-v2"><code>wait</code> + <code>notify/notifyAll</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition-await-signal-signalAll"><code>Condition</code> + <code>await</code> + <code>signal/signalAll</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多个Condition精准唤醒">多个<code>Condition</code>精准唤醒</h2><ul><li>循环打印：打印5次 - 打印10次 - 打印15次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; :: &quot;</span> + i + <span class="string">&quot; : loop: &quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; :: &quot;</span> + i + <span class="string">&quot; : loop: &quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; :: &quot;</span> + i + <span class="string">&quot; : loop: &quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>区别</h1><ul><li><code>synchronized</code></li><li><code>Lock</code></li><li><code>Lock</code> + <code>Condition</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> synchronized </tag>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fork/Join 框架</title>
      <link href="/concurrency/concurrency/concurrent-notes/fork-join/"/>
      <url>/concurrency/concurrency/concurrent-notes/fork-join/</url>
      
        <content type="html"><![CDATA[<h1>Fork/Join 框架</h1><ul><li>Fork：把一个复杂任务进行分拆</li><li>Join：把分拆任务的结果进行合并</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/fork-join-framework.png" alt="fork-join-framework"></p><span id="more"></span><h2 id="ForkJoinTask">ForkJoinTask</h2><ul><li><code>ForkJoinTask</code>提供了任务中执行<code>fork()</code>和<code>join()</code>的机制</li><li>通常情况下不需要直接生成<code>ForkJoinTask</code>类，只需要继承它的子类<ul><li><code>RecursiveTask</code>：用于有返回结果的任务</li><li><code>RecursiveAction</code>：用于没有返回结果的任务</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/recursive-task.png" alt="recursive-task"></p><h2 id="ForkJoinPool">ForkJoinPool</h2><ul><li><code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>执行</li><li>类比线程池</li></ul><h2 id="实现原理">实现原理</h2><ul><li><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成，<code>ForkJoinTask</code>数组负责将存放以及将程序提交给<code>ForkJoinPool</code>，而 <code>ForkJoinWorkerThread </code>负责执行这些任务</li></ul><h1>Fork 方法</h1><ul><li>当调用 <code>ForkJoinTask</code> 的 <code>fork</code> 方法时，程序会把任务放在 <code>ForkJoinWorkerThread</code> 的 <code>workQueue</code> 的<code>push</code>中，异步执行这个任务，然后立即返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>push</code> 方法把当前任务存放在 <code>ForkJoinTask</code> 数组队列里；然后再调用 <code>ForkJoinPool</code> 的 <code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="built_in">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="literal">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Join 方法</h1><ul><li><code>Join</code> 方法的主要作用是阻塞当前线程并等待获取结果</li><li>首先调用 <code>doJoin </code>方法，通过 <code>doJoin()</code> 方法得到当前任务的状态来判断返回什么结果</li><li>任务状态有 4 种<ol><li>已完成（<code>NORMAL</code>）</li><li>被取消（<code>CANCELLED</code>）</li><li>信号（<code>SIGNAL</code>）</li><li>出现异常（<code>EXCEPTIONAL</code>）</li></ol></li><li>如果任务状态是已完成，则直接返回任务结果</li><li>如果任务状态是被取消，则直接抛出 <code>CancellationException</code></li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 doJoin()方法流程如下：<ol><li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态</li><li>如果没有执行完，则从任务数组里取出任务并执行</li><li>如果任务顺利执行完成，则设置任务状态为 <code>NORMAL</code>；如果出现异常，则记录异常，并将任务状态设置为 <code>EXCEPTIONAL</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line">    externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#异常处理</p><ul><li><code>ForkJoinTask</code> 在执行的时候可能会抛出异常，但没办法在主线程里直接捕获异常，所以 <code>ForkJoinTask</code> 提供了 <code>isCompletedAbnormally()</code> 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 <code>ForkJoinTask</code> 的 <code>getException</code> 方法获取异常</li><li><code>getException</code> 方法返回 <code>Throwable</code> 对象，如果任务被取消了则返回 <code>CancellationException</code>；如果任务没有完成或者没有抛出异常则返回 <code>null</code></li></ul><h1>用例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此种方法似乎不常用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(end - begin &lt;= VALUE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 任务切分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            <span class="type">AddTask</span> <span class="variable">addTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(begin, mid);</span><br><span class="line">            <span class="type">AddTask</span> <span class="variable">addTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步执行</span></span><br><span class="line">            addTask1.fork();</span><br><span class="line">            addTask2.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步阻塞获取结果</span></span><br><span class="line">            result = (<span class="type">int</span>) addTask1.join() + (<span class="type">int</span>) addTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="type">AddTask</span> <span class="variable">addTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建执行对象</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="comment">// 提交任务执行</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; result = forkJoinPool.submit(addTask);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭 forkJoinPool</span></span><br><span class="line">            forkJoinPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程锁</title>
      <link href="/concurrency/concurrency/concurrent-notes/multithread-lock/"/>
      <url>/concurrency/concurrency/concurrent-notes/multithread-lock/</url>
      
        <content type="html"><![CDATA[<h1><code>synchronized</code>实现同步</h1><ul><li><code>synchronized</code>实现同步的基础：Java 中的每一个对象都可以作为锁</li><li>具体表现为以下3种形式：<ul><li>对于普通同步方法，锁是当前实例对象<code>this</code></li><li>对于静态同步方法，锁是当前类的<code>Class</code>对象</li><li>对于同步方法块，锁是<code>synchronized</code>括号里配置的对象</li></ul></li></ul><span id="more"></span><h1>公平锁与非公平锁</h1><h2 id="应用">应用</h2><ul><li><p><code>synchronized</code>是非公平锁</p></li><li><p><code>new ReentrantLock(boolean fair)</code>，若不传参或<code>fair == false</code>则为非公平锁（默认采用非公平锁）；若<code>fair == true</code>则为公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="原理">原理</h2><p><a href="https://blog.csdn.net/numbbe/article/details/113243325">【锁】ReentrantLock如何实现公平锁/非公平锁</a></p><h2 id="不同">不同</h2><ul><li>公平锁与非公平锁就是等待队列中的线程排队不排队的问题</li></ul><h2 id="优劣">优劣</h2><h3 id="公平锁">公平锁</h3><ul><li>优点：大锅饭，统一分配资源</li><li>缺点：性能下降很多，第一个线程释放锁后，如果还想再次获取锁，需要进入等待队列尾部，重新排队，进入阻塞状态，等待CPU唤醒</li></ul><h3 id="非公平锁">非公平锁</h3><ul><li>优点：强者恒强，性能高</li><li>缺点：线程饥饿</li></ul><h1>可重入锁与非重入锁</h1><ul><li><code>synchronized</code>和<code>ReentrantLock</code>都是可重入锁，也称为<strong>递归锁</strong><ul><li><code>synchronized</code>称为“隐式”可重入锁，因为<code>synchronized</code>自动获取/释放锁</li><li><code>ReentrantLock</code>称为“显式”可重入锁，因为<code>Lock</code>需要手动获取/释放锁</li></ul></li></ul><h2 id="synchronized示例"><code>synchronized</code>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Obejct</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            ...;</span><br><span class="line">                <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">                ...;</span><br><span class="line">                    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">                        ...;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock示例"><code>ReentrantLock</code>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            ...;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            ...; </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>死锁</h1><h2 id="验证是否是死锁">验证是否是死锁</h2><ul><li><code>jps</code>：类似于 Linux 的<code>ps -ef</code></li><li><code>jstack</code>：JVM自带的堆栈跟踪工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Hexo 的博客搭建</title>
      <link href="/bo-ke-da-jian/blogbuilding/blog-build/"/>
      <url>/bo-ke-da-jian/blogbuilding/blog-build/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>之前的个人博客是基于<a href="https://docsify.js.org/#/zh-cn/">docsify</a>搭建的，本着多折腾才能多学习的精神，仅以本文记录搭建个人博客的过程。🐔</p><span id="more"></span><h1>博客环境准备</h1><h1>博客初始化</h1><h1>部署到GitHub</h1><h1>主题配置</h1><h2 id="主题切换">主题切换</h2><h2 id="创建页面">创建页面</h2><h2 id="支持-Emoji">支持 Emoji</h2><p><a href="https://blog.xaoxu.cn/archives/hexo-use-emoji">Hexo中使用emoji表情 (xaoxu.cn)</a></p><h2 id="代码高亮与复制">代码高亮与复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局搜索">全局搜索</h2><p><a href="https://www.jianshu.com/p/d388119a90ec">Hexo增加搜索功能 - 简书 (jianshu.com)</a></p><h2 id="中文链接转拼音">中文链接转拼音</h2><h2 id="字数统计">字数统计</h2><p><a href="https://github.com/theme-next/hexo-symbols-count-time">theme-next/hexo-symbols-count-time: Symbols count and time to read of articles for Hexo. (github.com)</a></p><h2 id="修改页脚">修改页脚</h2><p>待定</p><h2 id="社交链接">社交链接</h2><p><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%A4%BE%E4%BA%A4%E9%93%BE%E6%8E%A5">设置侧边栏社交链接 · iissnan/hexo-theme-next Wiki (github.com)</a></p><h2 id="评论系统">评论系统</h2>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/concurrency/concurrency/concurrent-notes/cas/"/>
      <url>/concurrency/concurrency/concurrent-notes/cas/</url>
      
        <content type="html"><![CDATA[<h1>原理</h1><ul><li>CAS 是 JDK 提供的非阻塞原子性操作，其通过硬件保证了比较-更新的原子性</li><li>实现方法：通过<code>Unsafe</code>提供的 CAS 方法（<code>compareAndSwapXxx</code>），底层实现是基于硬件平台的汇编指令，在 intel 的 CPU 中（x86机器上），使用的是汇编指令<code>cmpxchg</code>指令</li><li>核心思想：比较要更新变量的值<code>V</code>和预期值<code>E</code>（compare），相等才会将<code>V</code>的值设为新值<code>N</code>（swap），如果不相等则自旋</li><li>比起用<code>synchronized</code>重量级锁，CAS 的排他时间要短很多，因此在多线程情况下性能会比较好</li></ul><span id="more"></span><h1>源码分析</h1><blockquote><p>以<code>AtomicInteger</code>为例</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/atomic-integer.png" alt="atomic-integer"></p><h2 id="Unsafe">Unsafe</h2><ul><li><code>Unsafe</code>是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问，<code>Unsafe</code>相当于一个后门，基于该类可以直接操作特定内存的数据</li><li><code>unsafe</code>类存在于<code>sun.misc</code>包，其内部方法操作可以像C指针一样直接操作内存，因此 Java 中 CAS 操作的执行依赖于<code>Unsafe</code>类的方法</li><li><code>Unsafe</code>类中的所有方法都是由<code>native</code>修饰，即<code>Unsafe</code>类中的方法都直接调用操作系统底层资源执行相应任务</li></ul><h2 id="valueOffset">valueOffset</h2><ul><li>表示该变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的</li></ul><h2 id="value">value</h2><ul><li><code>value</code>用<code>volatile</code>修饰，保证了多线程之间的内存可见性</li></ul><h2 id="线程安全的i">线程安全的i++</h2><ul><li><code>i++</code>是线程不安全的，应使用<code>atomicInteger.getAndIncrement()</code></li><li><code>AtomicInteger</code>类主要利用 CAS + <code>volatile</code>保证可见性和有序性，<code>native</code>方法保证原子性</li></ul><h1>缺点</h1><ul><li>长时间自旋操作占用CPU资源</li><li><code>ABA</code>问题<ul><li>版本号解决，<code>AtomicStampedReference</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> CAS </tag>
            
            <tag> Unsafe </tag>
            
            <tag> atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>atomic</title>
      <link href="/concurrency/concurrency/concurrent-notes/atomic/"/>
      <url>/concurrency/concurrency/concurrent-notes/atomic/</url>
      
        <content type="html"><![CDATA[<h1>原子类</h1><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/atomic.png" alt="atomic"></p><span id="more"></span><h1>基本类型原子类</h1><h2 id="包含">包含</h2><ul><li><code>AtomicInteger</code></li><li><code>AtomicBoolean</code></li><li><code>AtomicLong</code></li></ul><h2 id="示例">示例</h2><ul><li>50个线程，每个线程对<code>MyNumber</code>执行1000次自增，所有线程完成后输出结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicAPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);  <span class="comment">// 等待50个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        myNumber.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();  <span class="comment">// 计数减一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();  <span class="comment">// 阻塞等待</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + myNumber.atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>数组类型原子类</h1><h2 id="包含-v2">包含</h2><ul><li><code>AtomicIntegerArray</code></li><li><code>AtomicLongArray</code></li><li><code>AtomicReferenceArray</code></li></ul><h1>引用类型原子类</h1><h2 id="AtomicReference">AtomicReference</h2><ul><li>示例：手写自旋锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;  <span class="comment">// 自旋操作</span></span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; spin lock-----&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">10</span>);  <span class="comment">// 确保线程A先于线程B启动</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicStampedReference">AtomicStampedReference</h2><ul><li>携带版本号（<code>version</code>）的引用类型原子类，可解决 CAS 的<code>ABA</code>问题<ul><li><code>AtomicStampedReference(V initialRef,  int initialStamp)</code></li></ul></li><li>解决修改过多少次的问题</li><li>状态戳原子引用</li></ul><h2 id="AtomicMarkableReference">AtomicMarkableReference</h2><ul><li>携带标记位（<code>flag</code>）的引用类型原子类<ul><li><code>AtomicMarkableReference(V initialRef,  boolean initialMark)</code></li></ul></li><li>解决是否修改过的问题，将状态戳简化为<code>true/false</code>，一次性的标记</li><li>状态戳（<code>true/false</code>）原子引用</li></ul><h1>对象的属性修改原子类</h1><h2 id="包含-v3">包含</h2><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新对象中<code>volatile int</code>类型字段的值</li><li><code>AtomicLongFieldUpdater</code>：原子更新对象中<code>volatile long</code>类型字段的值</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新对象中<code>volatile</code>引用类型字段的值</li></ul><h2 id="使用目的">使用目的</h2><ul><li>以线程安全的方式操作非线程安全对象内的某些字段</li></ul><h2 id="使用要求">使用要求</h2><ul><li>更新的对象属性必须使用<code>public volatile</code>修饰**（此处也是<code>volatile</code>的使用场景）**</li><li>因为对象的属性修改原子类都是<strong>抽象类</strong>，所以每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性</li></ul><h2 id="示例-v2">示例</h2><ul><li><code>AtomicIntegerFieldUpdater</code>为例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with Intellij IDEA</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Concurrent&lt;h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : AresNing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> : 10个线程，每个线程转账1000次，不使用synchronized，使用AtomicIntegerFieldUpdater</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">bankName</span> <span class="operator">=</span> <span class="string">&quot;CCB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;BankAccount&gt; atomicIntegerFieldUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, <span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicIntegerFieldUpdater.getAndIncrement(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">BankAccount</span> <span class="variable">bankAccount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        bankAccount.transfer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;result: &quot;</span> + bankAccount.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicReferenceFieldUpdater</code>为例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with Intellij IDEA</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Concurrent&lt;h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : AresNing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> : 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能被初始化一次，只有一个线程操作成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">isInit</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"></span><br><span class="line">    AtomicReferenceFieldUpdater&lt;MyVar, Boolean&gt; referenceFieldUpdater =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(MyVar.class, Boolean.class, <span class="string">&quot;isInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(referenceFieldUpdater.compareAndSet(<span class="built_in">this</span>, Boolean.FALSE, Boolean.TRUE)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;----- start init&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;----- over init&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;----- other thread is working&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceFieldUpdaterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyVar</span> <span class="variable">myVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyVar</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(myVar::init, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>原子操作增强类</h1><h2 id="包含-v4">包含</h2><ul><li><code>DoubleAccumulator</code></li><li><code>DoubleAdder</code></li><li><code>LongAccumulator</code></li><li><code>LongAdder</code></li></ul><h2 id="区别">区别</h2><ul><li><code>LongAdder</code>只能用来计算加减法，且从零开始计算</li><li><code>LongAccumulator</code>则提供了<strong>自定义的函数操作</strong></li></ul><h2 id="阿里开发要求">阿里开发要求</h2><blockquote><p>如果是 JDK8，<strong>推荐使用<code>LongAdder</code>对象</strong>，比<code>AtomicLong</code>性能更好（减少乐观锁的重试次数）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/alibaba-java.png" alt="alibaba-java"></p><h2 id="示例-v3">示例</h2><ul><li>热点商品点赞计数器，点赞数加加统计，不要求实时精确<ul><li>对比四种实现方法的性能：<code>synchronized</code>，<code>AtomicLong</code>，<code>LongAdder</code>，<code>LongAccumulator</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with Intellij IDEA</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Concurrent&lt;h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : AresNing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023-03-03 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> : 50个线程，每个线程点赞100w次，计算总点赞数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClickNumber</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clickBySynchronized</span><span class="params">()</span> &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByAtomicLong</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicLong.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAdder</span><span class="params">()</span> &#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccumulatorCompareDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1W</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClickNumber</span> <span class="variable">clickNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClickNumber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start;</span><br><span class="line">        <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span> * _1W; j++) &#123;</span><br><span class="line">                        clickNumber.clickBySynchronized();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch1.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch1.await();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;costTime: &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span> + <span class="string">&quot;\t clickBySynchronized: &quot;</span> + clickNumber.number);</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span> * _1W; j++) &#123;</span><br><span class="line">                        clickNumber.clickByAtomicLong();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch2.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;costTime: &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span> + <span class="string">&quot;\t clickByAtomicLong: &quot;</span> + clickNumber.atomicLong.get());</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span> * _1W; j++) &#123;</span><br><span class="line">                        clickNumber.clickByLongAdder();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch3.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;costTime: &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span> + <span class="string">&quot;\t clickByLongAdder: &quot;</span> + clickNumber.longAdder.sum());</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span> * _1W; j++) &#123;</span><br><span class="line">                        clickNumber.clickByLongAccumulator();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch4.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch4.await();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;costTime: &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span> + <span class="string">&quot;\t clickByLongAccumulator: &quot;</span> + clickNumber.longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">costTime: 933 ms clickBySynchronized: 50000000</span><br><span class="line">costTime: 586 ms clickByAtomicLong: 50000000</span><br><span class="line">costTime: 76 ms clickByLongAdder: 50000000</span><br><span class="line">costTime: 69 ms clickByLongAccumulator: 50000000</span><br></pre></td></tr></table></figure><h2 id="LongAdder-源码分析">LongAdder 源码分析</h2><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/long-adder.png" alt="long-adder"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/alibaba-java.png" alt="alibaba-java"></p><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/long-adder-diagram.png" alt="long-adder-diagram"></p><h3 id="LongAdder性能优于AtomicLong的原因">LongAdder性能优于AtomicLong的原因</h3><ul><li><code>LongAdder</code>的基本思路是<strong>分散热点</strong>，用空间换时间，将<code>value</code>值分散到一个<code>Cell</code>数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多；如果要获取真正的<code>long</code>值，只要将各个槽中的变量值累加返回<ul><li>在无竞争的情况下，<code>LongAdder</code>和<code>AtomicLong</code>一样，对同一个<code>base</code>进行操作</li><li>多个线程需要同时对<code>value</code>进行操作时，可以对线程 id 进行 hash 得到 hash 值，再根据 hash 值映射到<code>Cell</code>数组的某个下标，再对该下标对应的值进行自增操作</li><li>当所有线程操作完毕，将数组<code>Cell</code>的所有值和<code>base</code>都加起来作为最终结果</li></ul></li><li><code>sum()</code>会将所有<code>Cell</code>数组中的<code>value</code>和<code>base</code>累加作为返回值，核心的思想就是将之前<code>AtomicLong</code>一个<code>value</code>的更新压力分散到多个<code>value</code>中去，从而降低更新热点<ul><li><code>base</code>变量：低并发，直接累加到该变量上</li><li><code>Cell[]</code>数组：高并发，累加进各个线程自己的槽<code>Cell[i]</code>中</li><li>则最终的和为：$Value=Base+\sum_i^nCell[i]$</li></ul></li></ul><h3 id="longAdder-increment-为例">longAdder.increment() 为例</h3><ol><li><p><code>add(1L)</code></p><ul><li><p>如果<code>Cell[]</code>数组为空，尝试用 CAS 更新<code>base</code>字段，成功则退出；</p></li><li><p>如果<code>Cell[]</code>数组为空，CAS 更新<code>base</code>字段失败，出现竞争，<code>uncontended</code>为<code>true</code>，调用<code>longAccumulate</code></p></li><li><p>如果<code>Cell[]</code>非空，但当前线程映射的槽为空，<code>uncontended</code>为<code>true</code>，调用<code>longAccumulate</code></p></li><li><p>如果<code>Cell[]</code>非空，且当前线程映射的槽非空，CAS 更新<code>Cell</code>的值，成功则返回，否则，<code>uncontended</code>为<code>false</code>，调用<code>longAccumulate</code></p></li></ul></li><li><p><code>longAccumulate()</code></p><ul><li>首先给当前线程分配一个<code>hash</code>值，然后进入一个<code>for(;;)</code>自旋，这个自旋分为三个分支：<ul><li>CASE 1：<code>Cell[]</code>数组已经初始化了</li><li>CASE 2：<code>Cell[]</code>数组未初始化（首次新建），则尝试对它加锁，并初始化<code>Cell[]</code>数组</li><li>CASE 3：<code>Cell[]</code>数组正在初始化中，则尝试直接在基数<code>base</code>上进行累加操作</li></ul></li></ul></li><li><p><code>sum()</code></p><ul><li>会将<code>Cell[]</code>数组中的<code>value</code>和<code>base</code>累加作为返回值</li><li>其返回值不是原子性的快照，在并发情况下并非准确值</li></ul></li></ol><h3 id="LongAdder-与-AtomicLong-的对比">LongAdder 与 AtomicLong 的对比</h3><ul><li><code>AtomicLong</code><ul><li>线程安全，可允许一些性能损耗，要求高精度时可使用</li><li><strong>保证精度，牺牲性能作为代价</strong></li><li><code>AtomicLong</code>是多个线程针对单个热点值<code>value</code>进行原子操作</li></ul></li><li><code>LongAdder</code><ul><li>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</li><li><strong>保证性能，牺牲精度作为代价</strong></li><li><code>LongAdder</code>是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行 CAS 操作</li></ul></li></ul><h2 id="总结">总结</h2><h3 id="AtomicLong">AtomicLong</h3><ul><li>原理<ul><li>CAS + 自旋</li><li>常用方法为<code>incrementAndGet()</code></li></ul></li><li>场景<ul><li>低并发下的全局计算</li><li><code>AtomicLong</code>能保证并发情况下计数的准确性，其内部通过 CAS 来解决并发安全性的问题</li></ul></li><li>缺陷<ul><li>高并发后性能急剧下降</li><li>原因：<code>AtomicLong</code>的自旋会成为瓶颈，N个线程 CAS 操作修改值，每次只有一个成功过，其他N-1失败，失败的线程会不断自旋直到成功，这样大量失败自旋，会导致CPU占用率升高</li></ul></li></ul><h3 id="LongAdder">LongAdder</h3><ul><li>原理<ul><li>CAS + Base + Cell数组分散热点</li><li>空间换时间，并分散了热点数据</li></ul></li><li>场景<ul><li>高并发下的全局计算</li></ul></li><li>缺陷<ul><li><code>sum</code>求和后还有计算线程修改结果的话，最后jie’guo</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> CAS </tag>
            
            <tag> atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列</title>
      <link href="/concurrency/concurrency/concurrent-notes/blocking-queue/"/>
      <url>/concurrency/concurrency/concurrent-notes/blocking-queue/</url>
      
        <content type="html"><![CDATA[<h1><code>BlockingQueue</code></h1><ul><li><strong>阻塞：在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</strong><ul><li>当队列是空的，从队列中获取元素的操作将会被阻塞</li><li>当队列是满的，从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多 个元素或者完全清空，使队列变得空闲起来并后续新增</li></ul></li><li>使用阻塞队列的原因：多线程环境中，通过队列可以很容易实现<strong>数据共享</strong><ul><li><strong>经典的“生产者”和 “消费者”模型</strong>中，通过队列可以很便利地实现两者之间的数据共享</li><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起）， 直到有数据放入队列，消费线程被自动唤醒</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起）， 直到队列中有空的位置，生产线程被自动唤醒</li></ul></li></ul><span id="more"></span><h1><code>BlockingQueue</code>核心方法</h1><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td><code>offer(e, time, unit)</code></td></tr><tr><td>移除</td><td><code>remove()</code></td><td><code>poll(e)</code></td><td><code>take()</code></td><td><code>poll(time, unit)</code></td></tr><tr><td>检查</td><td><code>element()</code></td><td><code>peek()</code></td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：当阻塞队列满/空时，再往队列里<code>add</code>插入/<code>remove</code>移除元素，会抛出异常</li><li>特殊值：插入方法，成功/失败返回<code>true</code>/<code>false</code>；移除方法，成功/失败返回队列元素/<code>null</code></li><li>一直阻塞：当阻塞队列满/空时，再往队列里<code>put</code>插入/<code>take</code>移除元素，会一直阻塞直到操作成功或响应中断退出</li><li>超时退出：阻塞一定时间，超过限时后会退出</li></ul><h1>常用的<code>BlockingQueue</code></h1><h2 id="ArrayBlockingQueue"><code>ArrayBlockingQueue</code></h2><h2 id="LinkedBlockingQueue"><code>LinkedBlockingQueue</code></h2><h2 id="DelayQueue"><code>DelayQueue</code></h2><h2 id="PriorityBlockingQueue"><code>PriorityBlockingQueue</code></h2><h2 id="SynchronousQueue"><code>SynchronousQueue</code></h2>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> BlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runnable 接口与 Callable 接口</title>
      <link href="/concurrency/concurrency/concurrent-notes/callable-interface/"/>
      <url>/concurrency/concurrency/concurrent-notes/callable-interface/</url>
      
        <content type="html"><![CDATA[<h1><code>Runnable</code>接口与<code>Callable</code>接口</h1><span id="more"></span><h2 id="是否有返回值">是否有返回值</h2><ul><li><code>Runnable</code>没有返回值</li><li><code>Callable</code>有返回值</li></ul><h2 id="是否抛出异常">是否抛出异常</h2><ul><li><code>Runnable</code>不抛出异常</li><li><code>Callable</code>抛出异常</li></ul><h2 id="实现方法名称不同">实现方法名称不同</h2><ul><li><code>Runnable</code>需要实现<code>run</code>方法</li><li><code>Callable</code>需要实现<code>call</code>方法</li></ul><h1><code>Future</code>接口</h1><ul><li>当<code>call()</code>方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用<code>Future </code>对象</li><li>将<code>Future</code>视为保存结果的对象：它可能暂时不保存结果，但将来会保存（一旦<code>Callable</code>返回）</li><li><code>Future</code>基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写5种方法，比较麻烦，通常使用<code>FutureTask</code></li></ul><h1>使用：<code>FutureTask</code></h1><ul><li>找一个类，既与<code>Runnable</code>有关系，也与<code>Callable</code>有关系</li><li><code>FutureTask</code>实现<code>Runnable</code>和<code>Future</code>，并方便地将两种功能组合在一起。 可以通过为其构造函数提供<code>Callable</code>来创建<code>FutureTask</code><ul><li><code>FutureTask(Callable&lt;V&gt; callable) </code></li><li>然后，将<code>FutureTask</code>对象提供给<code>Thread</code>的构造函数以创建<br><code>Thread</code>对象。因此，间接地使用<code>Callable</code>创建线程</li></ul></li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 <code>get</code> 方法</li><li>一旦计算完成，就不能再重新开始或取消计算</li><li><code>get </code>方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</li><li><code>get </code>只计算一次，因此 <code>get </code>方法放到最后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1, <span class="string">&quot;aa&quot;</span>).start();  <span class="comment">// Callable</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2, <span class="string">&quot;bb&quot;</span>).start();  <span class="comment">// Callable</span></span><br><span class="line">    <span class="comment">// Runnable</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="number">400</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(futureTask1.get());  <span class="comment">// 会阻塞在get方法，直到返回结果或抛出异常</span></span><br><span class="line">    System.out.println(futureTask2.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> Runnable </tag>
            
            <tag> Callable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture</title>
      <link href="/concurrency/concurrency/concurrent-notes/completable-future/"/>
      <url>/concurrency/concurrency/concurrent-notes/completable-future/</url>
      
        <content type="html"><![CDATA[<h1>Future 不足之处</h1><blockquote><p><code>Future</code>在 Java 里通常用来表示一个异步任务的引用，比如将任务提交到线程池里面，会得到一个<code>Future</code>，在<code>Future</code>里面有<code>isDone</code>方法来判断任务是否结束，<code>get</code>方法来一直阻塞知道任务结束然后获取结果</p></blockquote><span id="more"></span><ol><li>不支持手动完成<ul><li>假设提交了一个任务，但该任务执行太慢，此时已通过其他路径获取了任务结果，但无法把任务结果通知正在执行的线程，因此必须主动取消或一直等待它执行</li></ul></li><li>不支持进一步的非阻塞调用<ul><li><code>Future</code>的<code>get</code>方法会一直阻塞到任务完成，但如果想在获取任务之后执行额外的任务，因为<code>Future</code>不支持回调函数，因此无法实现该功能</li></ul></li><li>不支持链式调用<ul><li>对于<code>Future</code>的执行结果，如果想继续传到下一个<code>Future</code>处理使用，从而形成一个链式的<code>pipeline</code>调用，这在<code>Future</code>中无法实现</li></ul></li><li>不支持多个<code>Future</code>合并<ul><li>假设有多个<code>Future</code>并行执行，想在所有<code>Future</code>运行完毕之后，执行某些函数，这是无法通过<code>Future</code>实现的</li></ul></li><li>不支持异常处理<ul><li><code>Future</code>没有任何异常处理的API，因此在异步运行时，不好进行故障定位</li></ul></li></ol><h1>CompletableFuture</h1><p><img src="https://cdn.jsdelivr.net/gh/AresNing/PrivateImg/img/completable-future.png" alt="completable-future"></p><h2 id="简介">简介</h2><ul><li><code>CompletableFuture</code>被用于异步编程，可以通过毁掉的方式处理计算结果，也提供了转换和组合<code>CompletableFuture</code>的方法</li><li><code>CompletableFuture</code>可能代表了一个明确的<code>Future</code>，也有可能代表一个完成阶段（<code>CompletionStage</code>），它支持在计算完成后触发一些函数或执行某些动作</li><li><code>CompletableFuture</code>实现了<code>Future</code>，<code>CompletionStage</code>接口，实现了<code>Future</code>接口就可以兼容现有线程池框架，而<code>CompletionStage</code>接口才是异步编程的接口抽象，里面定义多种异步方法</li></ul><h2 id="四个核心的静态方法">四个核心的静态方法</h2><h3 id="介绍">介绍</h3><ul><li><p><strong>不建议直接使用<code>CompletableFuture</code>的空参构造器创建<code>CompletableFuture</code>，而是使用四个核心的静态方法，来创建一个异步任务</strong></p></li><li><p>四个核心的静态方法</p><ul><li><code>runAsync</code>无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br></pre></td></tr></table></figure><ul><li><code>supplyAsync</code>有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure><blockquote><p>上述<code>Executor executor</code>参数说明：</p><ul><li>没有指定<code>Executor</code>的方法，直接使用默认的<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码，此时相当于是守护线程</li><li>如果指定线程池，则是使用自定义或者特别指定的线程池执行异步代码，此时则是用户线程，记得关闭线程池</li></ul></blockquote></li></ul><h3 id="初步示例">初步示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 无返回值的</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line"></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 有返回值的</span></span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello supplyAsync&quot;</span>;</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line"></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用示例：减少阻塞和轮询">通用示例：减少阻塞和轮询</h3><ul><li><code>CompletableFuture</code>是<code>Future</code>的功能增强版，减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法</li><li>主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--- come in&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------1 second later: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(result &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;, threadPool).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----whenComplete come in&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;mission completed: &quot;</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;异常情况：&quot;</span> + e.getCause() + <span class="string">&quot;\t&quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--- main thread come in&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例：电商网站的比价需求">案例：电商网站的比价需求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with Intellij IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> : 从各网站查询商品价格，统计耗时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureMallDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tb&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tMall&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">                .stream().map(netMall -&gt;</span><br><span class="line">                        String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                                netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream().map(netMall -&gt; CompletableFuture.supplyAsync(() -&gt;</span><br><span class="line">                String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                        netMall.getNetMallName(),</span><br><span class="line">                        netMall.calcPrice(productName))))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .stream()</span><br><span class="line">                .map(s -&gt; s.join())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list1 = getPrice(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        list1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;------costTime: &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = getPriceByCompletableFuture(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        list2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end2= System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;------costTime: &quot;</span> + (end2 - start2) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);  <span class="comment">// 模拟查询时间</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入门">入门</h2><h3 id="使用CompletableFuture">使用<code>CompletableFuture</code></h3><ul><li>主线程中创建一个<code>CompletableFuture</code>，主线程调用<code>get</code>方法会阻塞，最后在一个子线程中使其终止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">Completable</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始启动&quot;</span>);</span><br><span class="line">            <span class="comment">// 子线程睡眠5s</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">// 子线程中完成主线程</span></span><br><span class="line">            future.complete(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程调用get方法阻塞</span></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程获取结果&quot;</span> + future.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程完成，阻塞结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有返回值的异步任务">没有返回值的异步任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    <span class="comment">// 运行一个没有返回值的异步任务</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程开始&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//主线程阻塞</span></span><br><span class="line">    future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有返回值的异步任务">有返回值的异步任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程开始&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程结束&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//主线程阻塞</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程结束, 子线程的结果为:&quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程依赖">线程依赖</h3><ul><li>当一个线程依赖另一个线程时，可以使用<code>thenApply</code>方法来把两个线程串行化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先对一个数先加10，然后取平方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;).thenApply(Integer -&gt; num * num);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程结束, 子线程的结果为:&quot;</span> + integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费任务结果">消费任务结果</h3><ul><li><code>thenAccpet</code>消费任务处理的结果，无返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先对一个数先加10，然后取平方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;).thenApply(Integer -&gt; num * num)</span><br><span class="line">        .thenAccept(integer -&gt; System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了 accept,结果为:&quot;</span> + integer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理">异常处理</h3><ul><li><code>exceptionally</code>异常处理，出现异常时触发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">        System.out.println(throwable.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>handle</code>类似于<code>thenApply</code>/<code>thenRun</code>方法，是最后一步的处理调用，但是同时可以处理异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;).handle((i, ex) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入handle方法&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ex != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生异常：&quot;</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正常完成，内容为&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果合并">结果合并</h3><ul><li><code>thenCompose</code>合并两个<strong>有依赖关系</strong>的<code>CompletableFuture</code>的执行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    <span class="comment">// 第一步加 10</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = future.thenCompose(integer -&gt; </span><br><span class="line">        <span class="comment">// 再创建一个CompletableFuture</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; integer + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">    System.out.println(future1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>thenCompose</code>合并两个<strong>没有依赖关系</strong>的<code>CompletableFuture</code>的执行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乘10任务开始&quot;</span>);</span><br><span class="line">        num *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 合并两个结果</span></span><br><span class="line">    CompletableFuture&lt;Object&gt; future = job1.thenCombine(job2, (BiFunction&lt;Integer, Integer, List&lt;Integer&gt;&gt;) (integer, integer2) -&gt; &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(integer);</span><br><span class="line">        list.add(integer2);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;合并结果：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>合并<strong>多个</strong>任务的结果：<code>allOf</code>与<code>anyOf</code></li></ul><ol><li><code>allOf</code>：一系列独立的<code>future</code>任务，所有任务执行完成后再进行下一步，或者使用<code>stream</code>和<code>Completable.join</code>方法将任务结果进行合并</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.add(job1);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乘10任务开始&quot;</span>);</span><br><span class="line">        num *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.add(job2);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;减10任务开始&quot;</span>);</span><br><span class="line">        num -= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.add(job3);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除10任务开始&quot;</span>);</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.add(job4);</span><br><span class="line"><span class="comment">// 多任务合并</span></span><br><span class="line">    List&lt;Integer&gt; collect = list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>anyOf</code>：只要在多个<code>future</code>里面有一个返回，整个任务结束，而不需要等到每一个<code>future</code>结束</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加10任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    futures[<span class="number">0</span>] = job1;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;乘10任务开始&quot;</span>);</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    futures[<span class="number">1</span>] = job2;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;减10任务开始&quot;</span>);</span><br><span class="line">            num -= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    futures[<span class="number">2</span>] = job3;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;除10任务开始&quot;</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    futures[<span class="number">3</span>] = job4;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法总结">常用方法总结</h2><h3 id="获得结果和触发计算">获得结果和触发计算</h3><h4 id="获取结果">获取结果</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>T get()</code></td><td>阻塞</td></tr><tr><td><code>T get(long timeout, TimeUnit unit)</code></td><td>阻塞，设置超时时间</td></tr><tr><td><code>join()</code></td><td>阻塞，无需处理异常</td></tr><tr><td><code>getNow(T valueIfAbsent)</code></td><td>立即获取结果不阻塞：计算完成，返回计算结果；计算不完成，返回<code>valueIfAbsent</code>值</td></tr></tbody></table><h4 id="主动触发计算">主动触发计算</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean complete(T value)</code></td><td>是否打断<code>get()/join()</code>方法返回<code>value</code>值</td></tr></tbody></table><h3 id="对计算结果进行处理">对计算结果进行处理</h3><h4 id="thenApply">thenApply</h4><ul><li>计算结果存在依赖关系，两个线程串行化</li><li>异常相关：由于存在依赖关系，当前步骤出异常，则停止，不会继续执行</li></ul><h4 id="handle">handle</h4><ul><li>计算结果存在依赖关系，两个线程串行化</li><li>异常相关：有异常也可以往下一步走，根据设置的异常参数可进一步处理</li></ul><blockquote><p><strong>比较：</strong></p><ul><li><code>exceptionally</code>类似于<code>try/catch</code></li><li><code>handle + whenComplete</code>类似于<code>try/finally</code></li></ul></blockquote><h3 id="对计算结果进行消费">对计算结果进行消费</h3><h4 id="thenAccept">thenAccept</h4><ul><li>接收任务的处理结果，并消费处理，无返回结果</li><li>类似于<code>Consumer</code>接口</li></ul><h4 id="对比补充：任务之间的顺序执行">对比补充：任务之间的顺序执行</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>thenRun(Runnable runnable)</code></td><td>任务A执行完毕执行任务B，并且B不需要A的结果</td></tr><tr><td><code>thenAccept(Consumer action)</code></td><td>任务A执行完毕执行任务B，B需要A的结果，但是任务B无返回值</td></tr><tr><td><code>thenApply(Function fn)</code></td><td>任务A执行完毕执行任务B，B需要A的结果，同时任务B有返回值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</span><br><span class="line">    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(System.out::println).join());</span><br><span class="line">    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(r -&gt; r + <span class="string">&quot; resultB&quot;</span>).join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output:</span></span><br><span class="line">null</span><br><span class="line">resultA</span><br><span class="line">null</span><br><span class="line">resultA resultB</span><br></pre></td></tr></table></figure><h3 id="对计算结果进行选用">对计算结果进行选用</h3><h4 id="applyToEither">applyToEither</h4><ul><li><code>public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</code></li><li>两个任务，谁先执行完毕，谁的任务结果作为参数传入<code>function</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; mission_a = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mission A come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;resultA&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; mission_b = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mission B come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;resultB&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; result = mission_a.applyToEither(mission_b, f -&gt; f + <span class="string">&quot; is completed first!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--------&quot;</span> + result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output:</span></span><br><span class="line">Mission A come in</span><br><span class="line">Mission B come in</span><br><span class="line">main--------resultB is completed first!!!</span><br></pre></td></tr></table></figure><h3 id="对计算结果进行合并">对计算结果进行合并</h3><h4 id="thenCombine">thenCombine</h4><ul><li><code>public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</code></li><li>两个<code>CompletionStage</code>任务都完成后，最终把两个任务的结果一起交给<code>thenCombine</code>来处理，先完成的先等待，等待其他分支任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分开写法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; result = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合并结果&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并写法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; result2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;), (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合并结果&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(result2.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对线程池说明">针对线程池说明</h3><ul><li>没有传入自定义线程池<code>Executor</code>：都用默认线程池<code>ForkJoinPool</code></li><li>传入自定义线程池：如果在执行第一个任务时，传入一个自定义线程池<ul><li>调用<code>thenRun</code>方法执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池</li><li>调用<code>thenRunAsync</code>方法执行第二个任务时，则第一个任务使用的是自己传入的线程池，第二个任务使用的是<code>ForkJoin</code>线程池，或者是调用<code>thenRunAsync</code>方法传入的线程池</li></ul></li><li>但会有例外，有可能处理太快，系统优化切换原则，直接用<code>main</code>线程处理</li><li>其他如：<code>thenAccept</code>与<code>thenAcceptAsync</code>，<code>thenApply</code>与<code>thenApplyAsync</code>等，其之间的区别同理</li></ul><h2 id="CompletionStage">CompletionStage</h2><ul><li>代表异步计算过程中的某一个阶段，一个阶段完成以后<strong>可能会触发</strong>另外一个阶段</li><li>一个阶段的计算执行可以是一个 <code>Funtion</code>，<code>Consumer</code> 或者 <code>Runnable</code><ul><li>比如：<code>stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() -&gt; System.out.println())</code></li></ul></li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起出发</li></ul>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> CompletableFuture </tag>
            
            <tag> Future </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test-blog</title>
      <link href="/cate3/cate4/test-blog/"/>
      <url>/cate3/cate4/test-blog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cate1 </category>
          
          <category> cate2 </category>
          
          <category> cate3 </category>
          
          <category> cate4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tag1 </tag>
            
            <tag> tag2 </tag>
            
            <tag> tag3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
